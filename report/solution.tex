\chapter{Solution method}

The program takes two arguments, the length of a vector et their number.

\begin{verbatim}
test the arguments

for i in column
    tmp = norm (v, i, row)

	 for k in row
        q[k][i] = v[k][i]/tmp

    for j from i+1 in col
        sigma = scalar_product(q,i,v,j,row)
        for k in row
            v[k][j] -= sigma*q[k][i]
\end{verbatim}

For the direct parallelization (using the \textit{for} directive), we parallelize the second for loop:
\begin{verbatim}
for j from i+1 in col
\end{verbatim}

We chose to parallelize that loop because it is perfectly parallel. Indeed, 
if we consider $i$ as being a constant, we can see that each iteration in the $j$-loop can be made alone. This is not the case with the outer-most loop.Indeed, the $j$-loop uses data that were computed in a previous iteration of the $i$-loop. Therefore, it is not possible to parallelize that loop.\\ 

In the task parallelization, we use \verb+#pragma omp single+ before the first loop:
\begin{verbatim}
for i in column
\end{verbatim}

and we add the task directive \verb+ #pragma omp task private(j, sigma, k, temp_norm)+ inside the body of the $i$-loop.
